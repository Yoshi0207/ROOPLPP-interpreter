// LinkedList
class Cell
    Cell next
    Object data

    method add(Cell head, int index, int i, Cell cell)
	if index != i && cell != nil then
	    i += 1
	    call next::add(head, index, i, cell)
	fi index = i && cell = nil

	local Cell tmp = nil
	local int j = 0
	call head::get(index - 1, j, tmp)
	if index = i && cell != nil then
	    cell.next <=> this
	    this <=> cell
        fi index = i && cell = nil && tmp.next = this
	uncall head::get(index - 1, j, tmp)
	delocal int j = 0
	delocal Cell tmp = nil

    method addLast(Cell cell)
        if next != nil && cell != nil then
	    call next::addLast(cell)
	fi this != nil && cell = nil

	if next = nil && cell != nil then
	    next <=> cell
	fi next.next = nil && cell = nil
	
    method get(int index, int i, Object x)      	
	if index != i && x = nil then
	    i += 1
	    call next::get(index, i, x)
	fi index = i && x != nil
	
        if index = i && x = nil then
	    copy Cell this x  
	fi index = i && x = this

    method indexOf(Object o, int index)
        if data != o then
	    index += 1
	    call next::indexOf(o, index)
	fi data != o
		
    method pretty()
        show(data)
    	if next != nil then
      	    print(" -> ")
      	    call next::pretty()
        fi next != nil

class LinkedList
    Cell head
    int length

    method insertHead(Cell cell)
        if head = nil & cell != nil then
      	    head <=> cell
        else skip
        fi head != nil & cell = nil
    	
    method add(Object o)
        call addLast(o)
	
    method add(int index, Object o)
//     	if index = 0 then
//	    call addFirst(o)
//        else
//	    if index = length then
//	        call addLast(o)
//	    else
//	        local Cell cell = nil
//  	    	new Cell cell
//     	    	cell.data ^= o
//            	local int i = 0
//     	    	call head::add(head, index, i, cell)
//     	    	delocal int i = index
//            	delocal Cell cell = nil
//	    	length += 1
//	    fi index = length - 1
//	fi index = 0

	switch index
	    case 0:      call addFirst(o) esac 0 break
	    case length: call addLast(o) esac length - 1 break
	    default:     local Cell cell = nil
  	    		 new Cell cell
      	    		 cell.data ^= o
            		 local int i = 0
      	    		 call head::add(head, index, i, cell)
      	    		 delocal int i = index
            		 delocal Cell cell = nil
	    		 length += 1
			 break
	hctiws index
	
    method addFirst(Object o)
        local Cell cell = nil
	new Cell cell
	cell.data ^= o
	call insertHead(cell)
	if head != nil && cell != nil then
            cell.next <=> head
            head <=> cell
	fi head != nil && cell = nil && head.next != nil
	delocal Cell cell = nil
	length += 1
	
    method addLast(Object o)            
        local Cell cell = nil
	new Cell cell	
	cell.data ^= o
	call insertHead(cell)
	if head != nil && cell != nil then
            call head::addLast(cell)
	fi head != nil && cell = nil && head.next != nil
	delocal Cell cell = nil
        length += 1
	
    method get(int index, Object x)
        local Cell cell = nil
        local int i = 0	
        call head::get(index, i, cell)
	x ^= cell.data
	uncall head::get(index, i, cell)
        delocal int i = 0
	delocal Cell cell = nil

    method size(int result)
        result ^= length
	
    method indexOf(Object o, int index)
        call head::indexOf(o, index)

    method remove(int index, Object o)
        uncall add(index, o)

    method pretty()
        print("Linked_List[")
    	call head::pretty()
    	print("]\n")	

// Stack
class Stack
    Object[] st
    int ptr
    int length

    method init(int n)
        new Object[n] st
	
    method isEmpty(int flag)
        if ptr = 0 then
	    flag ^= 1
	else
	    flag ^= 0
	fi ptr = 0

    method top(int x)
        x ^= st[ptr - 1]

    method push(int x)
        st[ptr] ^= x
    	ptr += 1
	length += 1
	
    method pop(Object x)
        uncall push(x)
	
    method size(int x)
        x ^= length

    method pretty()
        print("Stack[")
	for i in (0 .. length - 1) do
	    show(st[i])
	    if i != length - 1 then
	        print("; ")
	    fi i != length - 1
	end
	print("]\n")

// Queue
class Queue
    Object[] queue
    int tl
    int hd
    int length

    method init(int n)
        new Object[n] queue

    method top(int x)
        x ^= queue[hd]
	
    method isEmpty(int flag)
        if tl = 0 then
	    flag ^= 1
	else
	    flag ^= 0
	fi tl = 0
	
    method enqueue(Object o)
        queue[tl] ^= o
	tl += 1
	length += 1
	
    method dequeue(Object o)
        o ^= queue[hd]
	hd += 1

    method size(int x)
        x ^= length

    method pretty()
        print("Queue[")
	for i in (0 .. length - 1) do
	    show(queue[i])
	    if i != length - 1 then
	        print("; ")
	    fi i != length - 1
	end
	print("]\n")